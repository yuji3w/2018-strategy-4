#pragma config(Sensor, S1,     ,               sensorEV3_Color)
#pragma config(Sensor, S3,     ,               sensorEV3_Color)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


int  white[4]={85,94,85,85};
int black[4]= {10,10,10,10};
float Hhalfenc = 900;
float W= 98;
float H=115;
int initialAngle =0;
int Wout = (H/2)- 45;
int Hout = (W/2)-45;
int number_90 = 0;


void aligner(int speedSpinA, int speedSpinB, int speedSpinC, int angleMove, int speedMove);
float prop1=.6;
//float prop2=.5;

float normalizeRefl(tSensors n)
{
	return (1-(getColorReflected(n)-black[n])*1.0/(white[n]-black[n]));
}
float normalizeRefl1(tSensors n)
{
	return ((getColorReflected(n)-black[n])*1.0/(white[n]-black[n]));
}

void move(int speed,int angle)
{
	angle+= 0;

	setMotorSpeed(motorA, speed*cosDegrees(angle));
	setMotorSpeed(motorB, speed*cosDegrees(angle-120));
	setMotorSpeed(motorC, speed*cosDegrees(angle+120));
}
void moveVertical(int distance)
{ if (distance>0)
	{
		while (fabs(getMotorEncoder(motorB))<distance*18)
		{
			move (45, 270);
		}
	}
	else
	{
		while (fabs(getMotorEncoder(motorB))<fabs(distance*18))
		{
			move (45, 90);
		}
	}
	move(0,0);
}
void moveHorizontal(int distance1)
{
	if (distance1>0)
	{
		while (fabs(getMotorEncoder(motorB))<distance1*18/1.732)
		{
			move (45, 0);
		}
	}
	else
	{
		while (fabs(getMotorEncoder(motorB))<fabs(distance1*18/1.732))
		{
			move (45, 180);
		}
	}
	move(0,0);
}

void aligner(int speedSpinA, int speedSpinB, int speedSpinC, int angleMove, int speedMove)
{
	angleMove+=30;
	setMotorSpeed(motorA, speedSpinA+speedMove*cosDegrees(angleMove));
	setMotorSpeed(motorB, speedSpinB+speedMove*cosDegrees(angleMove-120));
	setMotorSpeed(motorC, speedSpinC+speedMove*cosDegrees(angleMove+120));
}
void spin(int speed)//NO CHANGE, NOT USED IN MAIN
{
	setMotorSpeed(motorA,speed);
	setMotorSpeed(motorB,speed);
	setMotorSpeed(motorC,speed);
}
void moveSpin(int speedSpin,int angleMove, int speedMove)
{
	angleMove+= 0;
	setMotorSpeed(motorA, speedSpin+speedMove*cosDegrees(angleMove));
	setMotorSpeed(motorB, speedSpin+speedMove*cosDegrees(angleMove-120));
	setMotorSpeed(motorC, speedSpin+speedMove*cosDegrees(angleMove+120));
}
int getmotorangle (int robotangle)
{
	return(robotangle*4.0*sqrt(3.0)/ 2.65);
}
void Spin(int angle, int speed)//USE IN MAIN
{
	int deg = (2*PI*8.4*angle)/18;
	resetMotorEncoder(motorA);
	spin(speed);
	while (abs(getMotorEncoder(motorA)) < deg)
		sleep(10);
	spin(0);
}
void spinna(int angle, int speed)
{
	int deg = (angle)*8.4*2*PI/18;
	resetMotorEncoder(motorC);
	while (abs(getMotorEncoder(motorc)) < deg)
	{
		spin(speed);
	}
	move(0,0);
}
/*void edge_align()
{
int edge_follow=0.46*colorStart[S1];
int edge_follow2=0.46*colorStart[S3];

while (getColorReflected(S1)<=edge_follow && getColorReflected(S3)>=edge_follow2) {
move(-10,90);
}
while (getColorReflected(S1)>=edge_follow && getColorReflected(S3) <= edge_follow2) {
move(10,90);
}
while (getColorReflected(S1)>=edge_follow && getColorReflected(S3)>= edge_follow2){
Spin(3,-10)
}
while (getColorReflected(S1)<=edge_follow && getColorReflected(S3)<=edge_follow2){
Spin(3,10);
}
}*/void edge_alignB()
{
	int speed1 = 20;
	int speed2 = 20;

	float A=0;
	float B=0;
	float C=0;
	float fr=(normalizeRefl(S1)-0.5);
	A+=-1*speed1*fr;
	B+=-0.68*speed1*fr;
	C+=0.43*speed1*fr;

	float fl = (normalizeRefl(S3)-0.5);
	A+=0.77*speed2*fl;
	B+=-0.32*speed2*fl;
	C+=1*speed2*fl;
	aligner(A,B,C,0,0);
	sleep(10);

}
void edge_align()
{
	int count=0;
	while(count<300)
	{

		float A=0;
		float B=0;
		float C=0;
		A=15.0*(normalizeRefl(S3)-0.5);
		B=-15.0*(normalizeRefl(S1)-0.5)*2;
		C=A;
		aligner(A,B,C,0,0);
		sleep(10);
		count++;
	}
	move(0,0);
}
/*void edgeFollowA()
{
float A;
float B;
float C;
while((getColorReflected(S1)-black[S1])*1.0/(white[S1]-black[S1])== 0.5)
{
A=15.0*(normalizeRefl(S3)-0.5);
B=-15.0*(normalizeRefl(S1)-0.5)*2.0;
C=A;
aligner(A,B,C,180,40);
sleep(10);
;
}
move(0,0);
}*/
void edgeFollowA()
{

	float A=0;
	float B=0;
	float C=0;
	A=24.5*(normalizeRefl(S3)-0.5);
	B=-24*(normalizeRefl(S1)-0.5)*2;
	C=A;
	aligner((A),(B),(C),0,25);

}

void edgeFollowB()
{

	float A=0;
	float B=0;
	float C=0;
	A=24.5*(normalizeRefl(S3)-0.5);
	B=-24*(normalizeRefl(S1)-0.5)*2;
	C=A;
	aligner((A),(B),(C),180,25);
}
void edgeFollowBU()
{
	if(normalizeRefl(S2)>0.5)
	{
		moveVertical(5);
		moveVertical(-5);
		if(number_90++<4)
		{
			spinna(90,20);
		}
	}
	float A=0;
	float B=0;
	float C=0;
	A=24.5*(normalizeRefl1(S3)-0.5);
	B=-24*(normalizeRefl1(S1)-0.5)*2;
	C=A;
	aligner((A),(B),(C),180,20);

}
void hit(int strength)
{
	setMotorBrakeMode(motorD,motorCoast);
	setMotorSpeed(motorD, -strength);
	sleep(600);
	setMotorSpeed(motorD, 5);
	sleep(100);
}

task main()
{
	spinna(initialAngle,30);
	sleep(200);
	resetMotorEncoder(motorA);
	moveHorizontal(-30);
	while(1)
	{
		edgeFollowBU();
		resetMotorEncoder(motorB);
		if( number_90>=4)
		{
			move(0,0);
			break;
		}
	}
	resetMotorEncoder(motorA);
	while (fabs(getMotorEncoder(motorA))<((3*W/4-7)*360/18)
	{
		edgeFollowBU();
	}
	resetMotorEncoder(motorB);
moveVertical(-H);
edge_align();
resetMotorEncoder(motorB);
	moveVertical((H/2)-19);
	resetMotorEncoder(motorB);
moveHorizontal(3*W/4+10);
resetMotorEncoder(motorB);
moveHorizontal(-(W/2- 12));
resetMotorEncoder(motorB);
moveVertical(H/2+23);
edge_align();
move(0,0);
sleep(200);
resetMotorEncoder(motorB);
spinna(90,30);
resetMotorEncoder(motorB);
moveHorizontal(10);
resetMotorEncoder(motorB);
moveVertical(W/2+11);
edge_align();
resetMotorEncoder(motorB);
moveVertical(-W);
edge_align();

	/*sleep(100);
	spinna(180,30);
	sleep(250);
	edge_align();
	resetMotorEncoder(motorB);
	moveHorizontal(-((H/2)-41-6);
	move(0,0);
	sleep(100);
	resetMotorEncoder(motorB);
	moveVertical(W);
	move(0,0);
	sleep(100);
	resetMotorEncoder(motorA);
	while (fabs(getMotorEncoder(motorA))<((H/2)*360/18)
	{
		edgeFollowBU();
	}
	edge_alignB();
	resetMotorEncoder(motorB);
	moveVertical(-W);
	sleep(100);
	edge_align();
	move(0,0);
	sleep(100);
	resetMotorEncoder(motorB);
	moveHorizontal((H*3/4)-30+9);
	move(0,0);
	sleep(100);
	edge_align();*/
	resetMotorEncoder(motorA);
	while( (fabs(getMotorEncoder(motorA)))<Hhalfenc)
	{
		edgeFollowB();

	}
	move(0,0);
	setMotorBrakeMode(motorD,motorCoast);
	setMotorSpeed(motorD, -100);
	resetMotorEncoder(motorB);
	moveVertical(W/2 - 15);//half didtance - 13.5
	move(0,0);
	sleep(300);
	setMotorSpeed(motorD,100);
	sleep(200);
	resetMotorEncoder(motorB);
	moveVertical(-(W/2 - 17));
	move(0,0)
	sleep(200);
	edge_align();
	resetMotorEncoder(motorB);
	moveHorizontal(H/2+10);
	resetMotorEncoder(motorB);
	moveVertical(5);


	sleep(100);

}
